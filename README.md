# HashMap и HashSet

## Памятка к домашнему заданию
Перед тем, как отправить своё решение на проверку преподавателю, сверьтесь с чеклистом

<details>
  <summary> Что делать, если возникли сложности? </summary>
  
  И это здорово! Если их преодолевать правильно, то можно получить большую образовательную пользу для себя. Периодическое возникновение вопросов, недопонимание пройденного материала - нормальная и неотъемлемая часть обучения. А мы здесь, чтобы помочь вам пройти этот путь.
  
  ### Что делать, если непонятна теория?
  1. Если подобный вопрос разбирался на лекции, посмотрите еще раз раздел с этой темой в видеозаписи.
  1. Если вопрос не решился, попробуйте поискать ответ самостоятельно в интернете, этот навык пригодится вам в работе.
  1. Если самостоятельно разобраться не удалось, задайте вопрос в общем чате, мы обязательно поможем.

  ### Что делать, если непонятно условие задания?
  1. Прежде чем задать вопрос по условию задачи, перечитайте его ещё раз и убедитесь, что в тексте условия нет прямого ответа на этот вопрос. Умение работать с текстом - важный навык работы с информацией.
  1. Если ответа на свой вопрос в тексте условия не увидели, задайте его в общем чате, мы раскроем детали условия подробнее. Не забудьте при этом скинуть и ссылку на условие задания, про которую у вас вопрос.

  ### Что делать,если не получается задача?
Если ваша проблема это **ошибка компиляции** (подчёркивает красным, не даёт запустить программу), сборки проекта, CI и прочие подобные ошибки, то:
  1. Найдите и прочитайте текст ошибки, который вам подсвечивает реплит, идея (или логи); "подчёркивает красным" - это не описание ошибки.
  1. Попробуйте понять текст ошибки, при необходимости воспользуйтесь переводчиком. Нестрашно, если вы переведёте неточно, тут главное сам процесс: со временем и с нашей помощью вы будете это делать лучше и лучше, но, пропуская этот этап, вы не сможете научиться это делать.
  1. Если не получилось понять ошибку по её тексту, попробуйте её загуглить и изучить подобную ошибку у других людей. Попробуйте примерить решения их проблем на свой код. Соотнесите найденные описания ошибки с пройденной теорией.
  1. Если все равно вашу трудности не разрешились, напишите в общий чат, обязательно указав:
      1. Название задачи и ссылку на условие
      1. Ссылку на вашу работу
      1. Текст и скриншот (не фотография) ошибки.
      1. Ваши размышления и описание шагов, которые вы совершили для решения.

Если ваша проблема это **ошибка исполнения** (программа умирает уже после запуска) или она **отрабатывает неправильно**, то:
  1. Воспользуйтесь отладчиком для пошагового анализа работы вашей программы. Так вы либо убедитесь в неправильности придуманного вами алгоритма или найдёте конкретное место, где ожидаемое поведение программы разошлось с фактическим.
  1. Если проблему найти не получилось, напишите в общий чат, обязательно указав:
      1. Название задачи и ссылку на условие
      1. Ссылку на вашу работу
      1. Конкретное и подробное описание проблемы или затруднения при решении задачи ("Помогите что не так" - это не описание)
      1. Подробное описание вашего анализа программы с помощью отладчика вместе со скринами
      1. Ваши размышления и описание шагов, которые вы совершили для решения.
  ---
  
</details>

<details>
  <summary> В решении выполнены все требования задания </summary>
  
  Убедитесь, что все требования задания выполнены. Для этого перед отправкой внимательно прочтите весь текст условия задания и соотнесите сказанное в нём с вашим решением. Навык самопроверки работы перед ревью пригодится вам как при обучении, так и на работе.

  ---
  
</details>

<details>
  <summary>Сдаём через гитхаб </summary>
  
  Время пришло познакомиться с профессиональными инструментами для контроля версий вашего кода. Теперь мы не сдаём домашние задания в реплите, а заливаем проект из идеи сразу же в публичный гитхаб-репозиторий. Одна задача - один репозиторий.
  
  Для того чтобы в репозитории не отслеживался всякий мусор, не забывайте добавлять `.gitignore`.
  В нём должны игнорироваться файлы идеи (правила `*.iml` и `.idea`), папки для автогенерируемых результатов сборки (`out`, позже - `target`).
  Этот файл должен находиться в корне вашего репозитория, а сам репозиторий должен быть инициализирован в корне вашего проекта.
  Т.е. открывая репозиторий вы должны сразу видеть папку `src`.
  Если вы забыли проигнорировать какие-либо файлы и они попали в репозиторий, используйте команду `git rm`.

</details>

## Задача 1 (обязательная)
Перед вами [классический](https://loremipsum.io/) для графического дизайна текст Lorem Ipsum:

>Lorem ipsum dolor sit amet, consectetur adipiscing elit, sed do eiusmod tempor incididunt ut labore et dolore magna aliqua. Ut enim ad minim veniam, quis nostrud exercitation ullamco laboris nisi ut aliquip ex ea commodo consequat. Duis aute irure dolor in reprehenderit in voluptate velit esse cillum dolore eu fugiat nulla pariatur. Excepteur sint occaecat cupidatat non proident, sunt in culpa qui officia deserunt mollit anim id est laborum.

Вам нужно определить, какая буква встречалась в нём чаще всего и какая реже всего.
Определить, является ли символ буквой можно с помощью встроенного статического метода `Character.isLetter` (поэкспериментируйте с ним, если сходу непонятно как им пользоваться или загуглите на него документацию - уже пора развивать этот навык).

Считать, конечно, нужно не руками.
Заведите в `Main` статическое текстовое поле с содержимым из текста выше, а в `main` напишите программу, решающую поставленную задачу.

### Подсказки
Заведите мапу `Map<Character, Integer>`, в которой для каждого символа будете хранить количество раз, которое вы его встретили.
Изначально мапа пустая. `Character` это ссылочный тип-обёртка для `char`, как `Integer` для `int`.

Пройдитесь циклом по символам строки. Символы можно получать по индексу с помощью метода `.charAt(ИНДЕКС)`.
Для каждого символа проверьте, есть ли он в мапе. Может быть два случая:
1. Его нет в мапе. Значит, мы встретили его в первый раз и вставляем в мапу пару где ключ это наш символ, а значение это 1 (тк встретили его всего один раз).
2. Он есть в мапе. Значит он нам уже встречался. Вынимаем текущее значение для ключа (нашего символа), увеличиваем это число на 1 и вставляем обратно в мапу.

В итоге после цикла у нас будет мапа частот с которой встречаются символы.

Всё что нам останется - пройтись по этой мапе и найти максимум и минимум.
Находить максимум в последовательности вы уже [умеете](./GIT_INTRO.md), останется только адаптировать эту логику для поиска не в массиве, а проходясь по мапе.
Поиск минимума абсолютно аналогичен (только вместо -1 возьмите `Integer.MAX_VALUE` - максимальное значение которое может быть у `int`).

## Задача 2 (обязательная)
Эта задача делается в новом репозитории.
Мы будем писать систему, которая будет быстро отвечать на вопрос, есть ли вводимое слово в тексте.

Создайте класс `WordsChecker` (проверятель слов). Пусть у него будет конструктор, в который передаётся текст, в котором мы будем проверять наличие слов.

Кроме конструктора у него должен быть метод `hasWord`, куда передаётся слово и который возвращает ответ на вопрос (`boolean`) о том, есть ли это слово в тексте или нет.

При этом это должно делаться эффективно - простым `text.contains(word)` не обойтись, тк это медленный полный перебор всего текста.
Вам предлагается разбить текст на слова (воспользуйтесь `text.split("\\P{IsAlphabetic}+");` для этого) и положить их в коллекцию для быстрой проверки наличия в ней слов через специальный метод коллекции.
Подумайте что это за коллекция должна быть и какой метод тут подойдёт.

Продемонстрируйте работу вашего класса в `Main` на примере текста Lorem ipsum из первого задания.

